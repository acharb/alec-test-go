#! /usr/bin/env bash
set -e

echo "hello"

export STELLAR_HOME="/opt/stellar"
export PGHOME="$STELLAR_HOME/postgresql"
export SUPHOME="$STELLAR_HOME/supervisor"
export COREHOME="$STELLAR_HOME/core"
export HZHOME="$STELLAR_HOME/horizon"

export PGBIN="/usr/lib/postgresql/12/bin/"
export PGDATA="$PGHOME/data"
export PGUSER="stellar"
export PGPORT=5432

ENABLE_HORIZON_CAPTIVE_CORE=false
ENABLE_CORE_MANUAL_CLOSE=false
ENABLE_CORE_ARTIFICIALLY_ACCELERATE_TIME_FOR_TESTING=false

QUICKSTART_INITIALIZED=false
CURRENT_POSTGRES_PID=""


function main() {
  echo ""
  echo "Starting start script"
  echo ""

  # docker-horizon-core repo stuff:

  echo ""
  echo "Starting Stellar Quickstart"
  echo ""

  process_args $*
  if [ "$NETWORK" != "standalone" ] && [ "$ENABLE_HORIZON_CAPTIVE_CORE" = "true" ]; then
    echo "--enable-horizon-captive-core is only supported in the standalone network" >&2
    exit 1
  fi
  if [ "$NETWORK" != "standalone" ] && [ "$ENABLE_CORE_ARTIFICIALLY_ACCELERATE_TIME_FOR_TESTING" = "true" ]; then
    echo "--enable-core-artificially-accelerate-time-for-testing is only supported in the standalone network" >&2
    exit 1
  fi
  if [ "$ENABLE_HORIZON_CAPTIVE_CORE" = "true" ] && [ "$ENABLE_CORE_ARTIFICIALLY_ACCELERATE_TIME_FOR_TESTING" = "true" ]; then
    echo "--enable-core-artificially-accelerate-time-for-testing is only supported without captive core" >&2
    exit 1
  fi

  echo "mode: $STELLAR_MODE"
  echo "network: $NETWORK ($NETWORK_PASSPHRASE)"

  copy_defaults
  init_db

}

function init_db() {
  if [ -f $PGHOME/.quickstart-initialized ]; then
    echo "postgres: already initialized"
    return 0
  fi
  pushd $PGHOME

  # workaround!!!! from: https://github.com/nimiq/docker-postgresql93/issues/2
  mkdir /etc/ssl/private-copy; mv /etc/ssl/private/* /etc/ssl/private-copy/; rm -r /etc/ssl/private; mv /etc/ssl/private-copy /etc/ssl/private; chmod -R 0700 /etc/ssl/private; chown -R postgres /etc/ssl/private
  # end workaround

  echo "postgres user: $PGUSER"

  set_pg_password

  run_silent "finalize-pgpass" sed -ri "s/__PGPASS__/$PGPASS/g" /opt/stellar/postgresql/.pgpass

  mkdir -p $PGDATA
  chown postgres:postgres $PGDATA
  chmod 0700 $PGDATA

  run_silent "init-postgres" sudo -u postgres $PGBIN/initdb -D $PGDATA

  start_postgres
  # run_silent "create-horizon-db" sudo -u postgres createdb horizon
  # run_silent "create-core-db" sudo -u postgres createdb core
  # run_silent "stellar-postgres-user" sudo -u postgres psql <<-SQL
  #   CREATE USER $PGUSER WITH PASSWORD '$PGPASS';
  #   GRANT ALL PRIVILEGES ON DATABASE horizon to $PGUSER;
  #   GRANT ALL PRIVILEGES ON DATABASE core to $PGUSER;
  # SQL

  # touch .quickstart-initialized
  # popd
}

function start_postgres() {
  if [ ! -z "$CURRENT_POSTGRES_PID" ]; then
    return 0
  fi

  echo $PGHOME
  echo $PGBIN
  echo $PGDATA

  # sudo -u postgres $PGBIN/postgres -D $PGDATA -c config_file=$PGHOME/etc/postgresql.conf
  # CURRENT_POSTGRES_PID=$!

  # # alec TODO - uncomment
  # # while ! sudo -u postgres psql -c 'select 1' &> /dev/null ; do
  # #   echo "Waiting for postgres to be available..."
  # #   sleep 1
  # # done

  # echo "postgres: up"
}



pushd () {
    command pushd "$@" > /dev/null
}

popd () {
    command popd "$@" > /dev/null
}

function set_pg_password() {

  if [ -n "$POSTGRES_PASSWORD" ]; then
    PGPASS=$POSTGRES_PASSWORD
    echo "using POSTGRES_PASSWORD"
    return 0
  fi

  # use a random password when ephemeral (or some other unknown mode)
  if [ "$STELLAR_MODE" != "persistent" ]; then
    PGPASS=$(head /dev/urandom | tr -dc 'a-zA-Z0-9' |  head -c 16)
    echo "postgres password: $PGPASS"
    return 0
  fi

  if [ -n "$PGPASS" ]; then
    echo "postgres password: $PGPASS"
    return 0
  fi

  # ask for a password when persistent
  read -s -p "Enter New Postgresql Password: " PGPASS
  echo ""
  read -s -p "Confirm: " PGPASS_CONFIRMATION
  echo ""

  if [ -z "$PGPASS" ]; then
    echo "Password empty" >&2
    exit 1
  fi

  if [ "$PGPASS" != "$PGPASS_CONFIRMATION" ]; then
    echo "Password mistmach" >&2
    exit 1
  fi

}

function process_args() {
  while [[ -n "$1" ]]; do
    ARG="$1"
    shift


    case "${ARG}" in
    --testnet)
      NETWORK="testnet"
      ;;
    --pubnet)
      NETWORK="pubnet"
      ;;
    --standalone)
      NETWORK="standalone"
      ;;
    --protocol-version)
      export PROTOCOL_VERSION="$1"
      shift
      ;;
    --enable-asset-stats)
      export ENABLE_ASSET_STATS="$1"
      shift
      ;;
    --enable-horizon-captive-core)
      ENABLE_HORIZON_CAPTIVE_CORE=true
      ;;
    --enable-core-manual-close)
      ENABLE_CORE_MANUAL_CLOSE=true
      ;;
    --enable-core-artificially-accelerate-time-for-testing)
      ENABLE_CORE_ARTIFICIALLY_ACCELERATE_TIME_FOR_TESTING=true
      ;;
    *)
      echo "Unknown container arg $ARG" >&2
      exit 1
    esac
  done

  # TODO: ask for what network to use
  if [ -z "$NETWORK" ]; then
    NETWORK="testnet"
  fi

  case "$NETWORK" in
  testnet)
    export NETWORK_PASSPHRASE="Test SDF Network ; September 2015"
    export HISTORY_ARCHIVE_URLS="https://history.stellar.org/prd/core-testnet/core_testnet_001"
    ;;
  pubnet)
    export NETWORK_PASSPHRASE="Public Global Stellar Network ; September 2015"
    export HISTORY_ARCHIVE_URLS="https://history.stellar.org/prd/core-live/core_live_001"
    ;;
  standalone)
    export NETWORK_PASSPHRASE="Standalone Network ; February 2017"
    # h1570ry - we'll start a webserver connected to history directory later on
    export HISTORY_ARCHIVE_URLS="http://localhost:1570"
    ;;
  *)
    echo "Unknown network: '$NETWORK'" >&2
    exit 1
  esac

  # Are we ephemeral or persistent?
  if [ -z "$STELLAR_MODE" ]; then
    if [ -f "/opt/stellar/.docker-ephemeral" ]; then
      STELLAR_MODE="ephemeral"
    else
      STELLAR_MODE="persistent"
    fi
  fi
}

function copy_defaults() {
  local CP="rsync -a"

  if [ -d $PGHOME/etc ]; then
    echo "postgres: config directory exists, skipping copy"
  else
    $CP /opt/stellar-default/common/postgresql/ $PGHOME
  fi

  if [ -d $SUPHOME/etc ]; then
    echo "supervisor: config directory exists, skipping copy"
  else
    $CP /opt/stellar-default/common/supervisor/ $SUPHOME
  fi

  if [ -d $COREHOME/etc ]; then
    echo "stellar-core: config directory exists, skipping copy"
  else
    $CP /opt/stellar-default/common/core/ $COREHOME
    $CP /opt/stellar-default/$NETWORK/core/ $COREHOME
  fi

  if [ -d $HZHOME/etc ]; then
    echo "horizon: config directory exists, skipping copy"
  else
    $CP /opt/stellar-default/common/horizon/ $HZHOME
  fi
}

# run_silent is a utility function that runs a command with an abbreviated
# output provided it succeeds.
function run_silent() {
  local LABEL=$1
  shift
  local COMMAND=$1
  shift
  local ARGS=$@
  local OUTFILE="/tmp/run_silent.out"

  echo -n "$LABEL: "
  set +e

  $COMMAND $ARGS &> $OUTFILE

  if [ $? -eq 0 ]; then
    echo "ok"
  else
    echo "failed!"
    echo ""
    cat $OUTFILE
    exit 1
  fi

  set -e
}

main $@